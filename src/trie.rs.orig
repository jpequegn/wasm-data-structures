use wasm_bindgen::prelude::*;
use std::collections::HashMap;

#[wasm_bindgen]
#[derive(Clone)]
pub struct TrieMetrics {
    pub total_insertions: u32,
    pub total_searches: u32,
    pub total_prefix_matches: u32,
    pub node_count: u32,
    pub max_depth: u32,
    pub average_word_length: f32,
}

struct TrieNode {
    children: HashMap<char, Box<TrieNode>>,
    is_end_of_word: bool,
    value: Option<u32>,
}

impl TrieNode {
    fn new() -> Self {
        TrieNode {
            children: HashMap::new(),
            is_end_of_word: false,
            value: None,
        }
    }
}

#[wasm_bindgen]
pub struct Trie {
    root: Box<TrieNode>,
    size: u32,
    metrics: TrieMetrics,
}

impl Trie {
    fn contains(&self, word: &str) -> bool {
        let mut current = &self.root;

        for ch in word.chars() {
            match current.children.get(&ch) {
                None => return false,
                Some(node) => current = node,
            }
        }

        current.is_end_of_word
    }

    fn update_metrics(&mut self) {
        if self.size == 0 {
            self.metrics.average_word_length = 0.0;
        } else {
            // Simplified: could calculate actual average
            self.metrics.average_word_length = (self.metrics.max_depth as f32) / 2.0;
        }
    }

    fn _delete_recursive(&mut self, node: &mut TrieNode, word: &str, depth: usize) -> Option<u32> {
        if depth == word.len() {
            if node.is_end_of_word {
                node.is_end_of_word = false;
                return node.value.take();
            }
            return None;
        }

        let ch = word.chars().nth(depth).unwrap();
        if let Some(child) = node.children.get_mut(&ch) {
            let result = self._delete_recursive(child, word, depth + 1);
            if result.is_some() && child.children.is_empty() && !child.is_end_of_word {
                node.children.remove(&ch);
                self.metrics.node_count -= 1;
            }
            return result;
        }
        None
    }

    fn _dfs_autocomplete(&self, node: &TrieNode, prefix: &str, results: &mut Vec<String>) {
        if node.is_end_of_word {
            results.push(prefix.to_string());
        }

        for (ch, child) in &node.children {
            let mut new_prefix = prefix.to_string();
            new_prefix.push(*ch);
            self._dfs_autocomplete(child, &new_prefix, results);
        }
    }
}

#[wasm_bindgen]
impl Trie {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Trie {
        Trie {
            root: Box::new(TrieNode::new()),
            size: 0,
            metrics: TrieMetrics {
                total_insertions: 0,
                total_searches: 0,
                total_prefix_matches: 0,
                node_count: 1,  // root
                max_depth: 0,
                average_word_length: 0.0,
            },
        }
    }

    pub fn insert(&mut self, word: String, value: u32) {
        let was_new = !self.contains(&word);

        let mut current = &mut self.root;
        let mut depth = 0u32;

        for ch in word.chars() {
            depth += 1;
            if !current.children.contains_key(&ch) {
                current.children.insert(ch, Box::new(TrieNode::new()));
                self.metrics.node_count += 1;
            }
            current = current.children.get_mut(&ch).unwrap();
        }

        current.is_end_of_word = true;
        current.value = Some(value);

        if was_new {
            self.size += 1;
        }

        if depth > self.metrics.max_depth {
            self.metrics.max_depth = depth;
        }

        self.metrics.total_insertions += 1;
        self.update_metrics();
    }

    pub fn search(&mut self, word: &str) -> Option<u32> {
        self.metrics.total_searches += 1;

        let mut current = &self.root;

        for ch in word.chars() {
            match current.children.get(&ch) {
                None => return None,
                Some(node) => current = node,
            }
        }

        if current.is_end_of_word {
            current.value
        } else {
            None
        }
    }

    pub fn starts_with(&mut self, prefix: &str) -> bool {
        self.metrics.total_prefix_matches += 1;

        let mut current = &self.root;

        for ch in prefix.chars() {
            match current.children.get(&ch) {
                None => return false,
                Some(node) => current = node,
            }
        }

        true
    }

    pub fn delete(&mut self, word: &str) -> bool {
        let result = self._delete_recursive(&mut self.root, word, 0);
        if result.is_some() {
            self.size -= 1;
            self.update_metrics();
            true
        } else {
            false
        }
    }

    pub fn autocomplete(&self, prefix: &str) -> Vec<JsValue> {
        let mut current = &self.root;

        for ch in prefix.chars() {
            match current.children.get(&ch) {
                None => return Vec::new(),  // Prefix not found
                Some(node) => current = node,
            }
        }

        let mut words = Vec::new();
        self._dfs_autocomplete(current, prefix, &mut words);
        words.sort();

        // Convert to JsValue for WASM compatibility
        words.into_iter()
            .map(|s| JsValue::from_str(&s))
            .collect()
    }

    pub fn get_metrics(&self) -> TrieMetrics {
        self.metrics.clone()
    }

    pub fn size(&self) -> u32 {
        self.size
    }

    pub fn is_empty(&self) -> bool {
        self.size == 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_insert_and_search() {
        let mut trie = Trie::new();
        trie.insert("hello".to_string(), 1);
        assert_eq!(trie.search("hello"), Some(1));
        assert_eq!(trie.search("hell"), None);
    }

    #[test]
    fn test_starts_with() {
        let mut trie = Trie::new();
        trie.insert("hello".to_string(), 1);
        assert!(trie.starts_with("hel"));
        assert!(trie.starts_with("hello"));
        assert!(!trie.starts_with("hi"));
    }

    #[test]
    fn test_multiple_insertions() {
        let mut trie = Trie::new();
        for i in 0..10 {
            trie.insert(format!("word{}", i), i);
        }
        assert_eq!(trie.size(), 10);
        for i in 0..10 {
            assert_eq!(trie.search(&format!("word{}", i)), Some(i));
        }
    }

    #[test]
    fn test_shared_prefixes() {
        let mut trie = Trie::new();
        trie.insert("test".to_string(), 1);
        trie.insert("testing".to_string(), 2);
        trie.insert("tester".to_string(), 3);
        assert_eq!(trie.search("test"), Some(1));
        assert_eq!(trie.search("testing"), Some(2));
        assert_eq!(trie.search("tester"), Some(3));
    }

    #[test]
    fn test_update_existing_word() {
        let mut trie = Trie::new();
        trie.insert("hello".to_string(), 1);
        trie.insert("hello".to_string(), 2);
        assert_eq!(trie.size(), 1);
        assert_eq!(trie.search("hello"), Some(2));
    }

    #[test]
    fn test_metrics_tracking() {
        let mut trie = Trie::new();
        for i in 0..50 {
            trie.insert(format!("word{}", i), i);
        }
        let metrics = trie.get_metrics();
        assert_eq!(metrics.total_insertions, 50);
        assert!(metrics.node_count > 50);  // More nodes than words (shared prefixes)
    }

    #[test]
    fn test_delete_word() {
        let mut trie = Trie::new();
        trie.insert("hello".to_string(), 1);
        assert!(trie.delete("hello"));
        assert_eq!(trie.search("hello"), None);
        assert_eq!(trie.size(), 0);
    }

    #[test]
    fn test_delete_missing_word() {
        let mut trie = Trie::new();
        assert!(!trie.delete("missing"));
    }

    #[test]
    fn test_autocomplete_basic() {
        let mut trie = Trie::new();
        trie.insert("test".to_string(), 1);
        trie.insert("testing".to_string(), 2);
        trie.insert("tester".to_string(), 3);

        let completions = trie.autocomplete("test");
        assert_eq!(completions.len(), 3);

        // Convert JsValues to check contents
        let completion_strings: Vec<String> = completions.iter()
            .map(|v| v.as_string().unwrap())
            .collect();
        assert!(completion_strings.contains(&"test".to_string()));
        assert!(completion_strings.contains(&"testing".to_string()));
        assert!(completion_strings.contains(&"tester".to_string()));
    }

    #[test]
    fn test_autocomplete_no_matches() {
        let mut trie = Trie::new();
        trie.insert("hello".to_string(), 1);

        let completions = trie.autocomplete("world");
        assert_eq!(completions.len(), 0);
    }

    #[test]
    fn test_delete_with_shared_prefixes() {
        let mut trie = Trie::new();
        trie.insert("test".to_string(), 1);
        trie.insert("testing".to_string(), 2);

        assert!(trie.delete("test"));
        assert_eq!(trie.search("test"), None);
        assert_eq!(trie.search("testing"), Some(2));
        assert!(trie.starts_with("test"));
    }

    #[test]
    fn test_empty_trie() {
        let trie = Trie::new();
        assert!(trie.is_empty());
        assert_eq!(trie.size(), 0);
    }

    #[test]
    fn test_metrics_node_count() {
        let mut trie = Trie::new();
        trie.insert("cat".to_string(), 1);
        trie.insert("car".to_string(), 2);

        let metrics = trie.get_metrics();
        // Should have: root + c + a + t + r = 5 nodes
        assert_eq!(metrics.node_count, 5);
    }

    #[test]
    fn test_max_depth_tracking() {
        let mut trie = Trie::new();
        trie.insert("a".to_string(), 1);
        trie.insert("testing".to_string(), 2);

        let metrics = trie.get_metrics();
        assert_eq!(metrics.max_depth, 7);  // "testing" has 7 characters
    }

    #[test]
    fn test_prefix_search_counts() {
        let mut trie = Trie::new();
        trie.insert("hello".to_string(), 1);

        assert!(trie.starts_with("hel"));
        assert!(trie.starts_with("h"));

        let metrics = trie.get_metrics();
        assert_eq!(metrics.total_prefix_matches, 2);
    }

    #[test]
    fn test_search_counts() {
        let mut trie = Trie::new();
        trie.insert("hello".to_string(), 1);

        let _ = trie.search("hello");
        let _ = trie.search("world");
        let _ = trie.search("test");

        let metrics = trie.get_metrics();
        assert_eq!(metrics.total_searches, 3);
    }

    #[test]
    fn test_delete_preserves_siblings() {
        let mut trie = Trie::new();
        trie.insert("cat".to_string(), 1);
        trie.insert("car".to_string(), 2);
        trie.insert("card".to_string(), 3);

        assert!(trie.delete("car"));
        assert_eq!(trie.search("car"), None);
        assert_eq!(trie.search("cat"), Some(1));
        assert_eq!(trie.search("card"), Some(3));
    }

    #[test]
    fn test_large_dataset() {
        let mut trie = Trie::new();

        for i in 0..1000 {
            trie.insert(format!("word_{}", i), i);
        }

        assert_eq!(trie.size(), 1000);

        for i in 0..1000 {
            assert_eq!(trie.search(&format!("word_{}", i)), Some(i));
        }
    }
}
